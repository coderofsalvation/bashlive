#!/bin/bash
#
# Copyright (C) 2014, Leon van Kammen (Coder of Salvation)
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 
TMPFILE="/tmp/.bashlive.$(whoami)"
C_NORMAL="\\033[0;0m"
C_RED="\\033[0;31m"
C_GREEN="\\033[0;32m"
TOKEN="|||"
INTERACTIVE=1
REPOS=("https://raw2.github.com/coderofsalvation/bashlive.repo/master/index.txt")

mybasename(){
  basename "${0//-/}" # mybasename does not like strings with '-' (which is the case with '-bash')
}

bashlive::update(){
  rm $TMPFILE* &>/dev/null; init 
}
  
init(){  
  [[ ! -f $TMPFILE.index.readable ]] && gencache 
}

gencache(){
  :>$TMPFILE.index
  for repo in "${REPOS[@]}"; do 
    printf "$C_GREEN""bashdown>$C_NORMAL indexing '$repo' into /tmp\n"; index="$(curl -s "$repo")"; [[ $? == 1 ]] && echo "failed" && continue 
    echo "$index" | tail -n+3 >> $TMPFILE.index; 
  done
  cat $TMPFILE.index | sed 's/'"$TOKEN"'.*//g' > $TMPFILE.index.readable
  printf "$C_GREEN""bashlive>$C_NORMAL done ($(cat $TMPFILE.index | wc -l) items were indexed)\n"; return 0
}

bashlives(){
  printf "$C_GREEN""the following bashlive's are available: $C_NORMAL\n\n"
  cat $TMPFILE.index.readable | cut -c 1-$(tput cols) | more 
  echo ""; 
  console;
}

tryget(){
  integer=$(echo "$1" | grep "^-\?[0-9]*$")
  (( "${#integer}" > 0 )) || get "$1"
  bashlivepath="$( grep "^$integer .*" $TMPFILE.index | sed 's/^[0-9]\+ //g' | trim | sed 's/ .*//g' )"
  get "$bashlivepath"
  includedbybash || console # dont do console when sourced by bash
}

# remove leading and trailing whitespaces
# usage: echo " foo bar " | trim 
 
trim(){
   cat - | sed -e 's/^ *//g' -e 's/ *$//g'
}

# checks if noninteractive mode should be triggered (if ':' is present in the bashlive path)
checkinteractive(){
  arg="$1"; [[ "$arg" =~ \!$ ]] && INTERACTIVE=0 || INTERACTIVE=1
}

is_file(){
  [[ -f "$1" ]] && return 0 || return 1
}

showfunctions(){
  set | grep " ()" | grep -v "_"
}

get(){
  is_file "$1" && scripthasbashlive && insert
  ! is_integer "$1" && [[ ! "$1" =~ "/" ]] && { search "$@"; return 0; } # search if no path given
  checkinteractive "$1"; arg="${1/\!/}"
  data="$(grep "$arg " $TMPFILE.index | head -n1 | sed "s/.*$TOKEN//g")"
  [[ ${#data} == 0 ]] && { printf "$C_RED""bashlive '$arg' not found $C_NORMAL\n"; return 1; }
  if [[ ! "$data" =~ ".git" ]]; then
    content="$(curl -s "$data")" || { printf "$C_RED""could not retrieve bashlive url '$data'$C_NORMAL\n"; return 1; }
    [[ "$INTERACTIVE" == "1" ]] && { printf "\n%s\n%s\n\n" "# source: ${data/\/raw*/}" "$content"; } | more | highlightcode
    trysource "$content" "$data" "$arg"
  else
    [[ "$INTERACTIVE" == "1" ]] && { printf "$C_GREEN"; read -p "clone $data into current dir? (y/n) " clone; [[ "$clone" == "y" ]] && git clone "$data"; }
    printf "$C_NORMAL"
  fi
}
/(){ get "$@"; } # alias

# highlights keywords in bashcode script
# @param backgroundcolorcode
# @param foregroundcolorcode
highlightcode(){
  GREP_COLOR='$1;$2' 
  cat - | grep -E --color 'usage|@param |@|$|http.*|sudo |su |curl |wget |bash |sh |if |then |while |for |do |\{|}|\|\||&&|$'
}
  
dosource(){  
  [[ "$INTERACTIVE" == "1" ]] && { 
    printf "$C_GREEN"; read -p "source? (y/n) " write; printf "$C_NORMAL"; 
    [[ ! "$write" == "y" ]] && return 0;
  } || printf "$C_GREEN""sourcing livebash $C_NORMAL'$3'\n" 1>&2;
  eval "${content/exit/return}"; 
  return 0 # replace 'exit'-calls with returns, and continue, even if errored
}

is_integer(){
  number=$( echo "$1" | sed 's/^[-+]*[0-9]*//g' ); [[ -z "$number" ]] && return 0 || return 1
}

trysource(){
  content="$1"; url="$2"; path="$3"; app="$(mybasename "$0" )";
  checkdependencies "$content" || return 0
  includedbybash && dosource "$content" "$url" "$path" && return 0; # dont ask  when sourced by /bin/bash
}

checkdependencies(){
  depends="$(echo "$1" | grep -E "@dependencies " | sed 's/.*dependencies //g' )"
  (( ${#depends} == 0 )) && return 0
  for depend in $depends; do 
    which $depend &>/dev/null || { printf "$C_RED[!] please install '$depend' first $C_NORMAL\n"; return 1; }
  done
  return 0
}

checkduplicatefunctions(){
  echo "$1" | grep -E "(\(\){|\(\)\n{)" | while read function; do 
    grep "$function" "$1" &>/dev/null && return 1
  done
  return 0
}

scripthasbashlive(){
  grep -E '.*(source|\.) .*bashlive.*' "$1" &>/dev/null; return $?
}

insert(){
  file="$(readlink -f "$0")"; 
  scripthasbashlive "$file" || { printf "$C_RED""could not find 'source bashlive' in your script :($C_NORMAL\n"; return 1; }
  read -p "bake bashlive into script? (y/n)" bake
  echo "*TODO*"
 # grep -E "^/ :/.*" "$file" )" > $TMPFILE.paths

 # code="$( cat "$file" | grep "^#"; printf "# inserted by bashlive (bashlive path: $path)\n# author: $url\n\n"; echo "$content" | grep -v "^#" )"
 # { IFS=''; cat "$file" | while read line; do :
 #     echo "$line"; if [[ "$line" =~ ". " ]] && [[ "$line" =~ "bashlive" ]]; then printf "\n%s\n" "$code"; fi
 #   done
 # } > $TMPFILE.insert;
 # echo "bashlive> writing backup to $TMPFILE.backup"; cp "$file" "$TMPFILE.backup";
 # cp "$TMPFILE.insert" "$file" || { printf "$C_RED""could not copy '$TMPFILE.insert' to '$file' :($C_NORMAL\n"; return 1; }
}

includedbybash(){
  appname="$(mybasename "$0")"; [[ "$appname" == "bash" ]] && return 0 || return 1;
}

usage(){
  TEXT='
  subcommands:
    
    bashlives                   list all bashlives
    search <keyword>          search for bashlives which match keyword
    bashlive::update                    refresh the (repo)list of bashlives 
    get <path>                print a bashlive (and optionally include it in your script)
    <number>                  print bashlive with given index (printed by "ls" or "search")
'
  echo "$TEXT"
}
help(){ usage; } # alias

console(){
  printf "$C_GREEN""bashlive> $C_NORMAL"; read -p "" cmd;
  [[ "${#cmd}" == 0 ]] && return 0 # exit on enter 
  # check if command is entered, or in case of an integer call get
  iscommand "${cmd/ */}" && ${cmd} || tryget "$cmd"
}

multimatch() { 
  awk 'BEGIN{for(i=1;i<ARGC;i++) a[i]=ARGV[i]; ARGC=1} {for (i in a) if ($0 !~ a[i]) next; print}' "$@"
}

search(){
  args="$*"; init; cat $TMPFILE.index.readable | multimatch "$@" | more | grep -E "${args// /|}"
  [[ -n $INCLUDED ]] && console
}

_bashlive_autocomplete(){ #  By convention, the function name  starts with an underscore.
  init; local cur
  # Pointer to current completion word.
  # By convention, it's named "cur" but this isn't strictly necessary.

  COMPREPLY=()   # Array variable storing the possible completions.
  cur=${COMP_WORDS[COMP_CWORD]}
  case "$cur" in
    *) 
       items="$( cat $TMPFILE.index.readable | sed 's/^[0-9]\+ //g' | trim | sed 's/ .*//g' | sed ':a;N;$!ba;s/\n/ /g' )"
       #explode $'\n' "COMPREPLY" "$(cat $TMPFILE.index.readable | sed 's/^[0-9]\+ //g' )"
       COMPREPLY=( $( compgen -W "$items" -- $cur ) )
       ;;
  esac

  return 0
}

explode(){
  IFS="$1" read -a $2 <<< "$3"
}

iscommand(){
  [[ "$1" == "help" ]] || [[ "$1" == "get" ]] || [[ "$1" == "search" ]] || [[ "$1" == "list" ]] || [[ "$1" == "bashlive::update" ]] && return 0
  return 1
}

cleanup(){
  printf "$C_NORMAL"
}

which sed grep awk which &>/dev/null || { echo "bashlive needs at least the following utilities: sed grep awk which"; }
[[ "$(mybasename "$0" )" != "bashlive" ]] && INCLUDED=1
if iscommand "$1"; then "$@"; else [[ ! -n $INCLUDED ]] && echo "type 'help' for help" &&  console; fi
complete -F _bashlive_autocomplete /
trap cleanup SIGTERM 2 3 15
includedbybash && {
  init; 
  printf "$C_GREEN""bashlive>$C_NORMAL %s\n" "type '/' + space and tab-away for online completion." 1>&2;
} 
